#!/usr/bin/env python

from dataclasses import dataclass
from typing import Optional
import protogen

# Import the protobuf definitions that have been generated with the official
# protobuf plugin for python.
import acme.longrunning.operations_pb2


@dataclass
class OperationInfo:
    response_type: protogen.Message
    metadata_type: protogen.Message


def operation_info(
    registry: protogen.Registry, method: protogen.Method
) -> Optional[OperationInfo]:
    # Any options set for the extension can be found in the `options` field of
    # the protobuf message they have been set on, here on the `Method`.
    pb = None
    for fd, msg in method.proto.options.ListFields():
        if fd.number == acme.longrunning.operations_pb2.OPERATION_INFO_FIELD_NUMBER:
            pb = msg
            break

    if pb is None:
        # The extension has not been set on the method.
        return None

    # pb is at this point a protobuf message as generated by the offical
    # protobuf plugin for python. In the example the extensions message type is
    # `operations_pb2.OperationInfo`.
    #
    # `operations_pb2.OperationInfo` has two fields: `response_type` and
    # `metadata_type` which themselfes reference protobuf messages by their
    # name. These names might be fully qualified like "google.protobuf.Empty" or
    # not fully qualified like `WriteBookRequest` which would resolve to
    # `acme.library.v1.WritebookRequest` given the current scope is the
    # `acme.library-v1.Library.WriteBook` service method. To resolve non
    # fully-qualified message names given a current scope as reference, use
    # `protogen.Registry.resolve_message_type`.

    operation_info = OperationInfo(
        registry.resolve_message_type(method.full_name, pb.response_type),
        registry.resolve_message_type(method.full_name, pb.metadata_type),
    )

    if operation_info.response_type is None:
        raise Exception(
            f"message {pb.response_type} could not be resolved from base {method.full_name}"
        )

    if operation_info.metadata_type is None:
        raise Exception(
            f"message {pb.metadata_type} could not be resolved from base {method.full_name}"
        )

    return operation_info


def generate(gen: protogen.Plugin):
    for f in gen.files_to_generate:
        g = gen.new_generated_file(
            f.proto.name.replace(".proto", "_ext.py"),
            f.py_import_path,
        )

        g.P("# Autogenerated code. DO NOT EDIT.")
        g.P(f'"""This is an module docstring."""')
        g.P()
        g.print_import()
        g.P()

        for service in f.services:
            g.P(f"class {service.py_ident.py_name}Client:")
            g.P(f"  def __init__(self, host: str):")
            g.P(f"    self.host = host")
            g.P()

            for method in service.methods:
                # Create a new class `<MethodName>Operation` for each response type
                # for each method that returns a acme.longrunning.Operation.
                if method.output.full_name == "acme.longrunning.Operation":
                    op = operation_info(gen.registry, method)
                    g.P(f"class {method.proto.name}Operation:")
                    g.P("  def wait() -> ", method.output.py_ident, ":")
                    g.P("    pass")
                    g.P()
                    g.P("  response_type:", op.response_type.py_ident)
                    g.P("  metadata_type:", op.metadata_type.py_ident)

                # fmt: off
                g.P(f"  def {method.py_name}(req: ", method.input.py_ident, ") -> ", method.output.py_ident, ":")
                g.P(f"    pass")
                g.P()
                # fmt: on


def options_py_import_func(proto_filename: str, proto_package: str):
    return protogen.PyImportPath(
        proto_filename.replace(".proto", "_ext").replace("/", ".")
    )


opts = protogen.Options(py_import_func=options_py_import_func)
opts.run(generate)

#!/usr/bin/env python

import protogen
import google.protobuf.compiler.plugin_pb2

dataclassesPackage = protogen.PyImportPath("dataclasses")


def generate(gen: protogen.Plugin):
    for f in gen.files_to_generate:
        # This plugin generates a file with suffix `_dataclasses.py` file for
        # each `.proto' file to generate. For a proto file "a/b/library.proto"
        # a python file "a/b/library_dataclasses.py" will be generated. The
        # python module name of this file is "a.b.library_dataclasses". This is
        # different from the behaviour assumed by default, which would generate
        # a "a/b/library_pb2.py" file that has a module name of "a.b.library_pb2".
        #
        # This changed module naming behaviour changes the way messages and need
        # to be imported between two python files: instead of importing the
        # "a.b.library" module when a message from the "a/b/library.proto" file
        # is referenced, the "a.b.library_dataclasses" module needs to be
        # imported.
        #
        # To import the correct modules, the python identifiers of the messages
        # the plugin has to work with (see `protogen.Message.py_ident`) must be
        # adjusted accordingly. This is done by providing the
        # `datalasses_py_import_func` to the `protogen.Options` below. With that
        # all messages will use the
        #
        #   ```
        #   proto_filename.replace(".proto", "_dataclasses").replace("/", ".")
        #   ```
        #
        # as the python import path.
        g = gen.new_generated_file(
            f.proto.name.replace(".proto", "_dataclasses.py"),
            f.py_import_path,
        )
        g.P("# Autogenerated code. DO NOT EDIT.")
        g.P(f'"""This is an module docstring."""')
        g.P()
        g.print_import()
        g.P()

        for message in f.messages:
            g.P("@", dataclassesPackage.ident("dataclass"))
            g.P(f"class {message.proto.name}:")
            g.P(f'  """{message.location.leading_comments}"""')
            g.P()

            for field in message.fields:
                if field.kind == protogen.Kind.MESSAGE:
                    g.P("  ", field.py_name, ": ", field.message.py_ident)
                elif field.proto.proto3_optional:
                    g.P(f"  {field.py_name}: str | None")  # use str for simplicity
                else:
                    g.P(f"  {field.py_name}: str")

            g.P()


def dataclasses_py_import_func(proto_filename: str, proto_package: str):
    return protogen.PyImportPath(
        proto_filename.replace(".proto", "_dataclasses").replace("/", ".")
    )


opts = protogen.Options(
    py_import_func=dataclasses_py_import_func,
    # To indicate to be able to handle proto3 optionals a protoc plugin must set
    # `google.protobuf.compiler.plugin_pb2.CodeGeneratorResponse.Feature.FEATURE_PROTO3_OPTIONAL`
    # in the `supported_features` list. This enum value will be delegated to
    # protoc via the CodeGeneratorResponse.supported_features field.
    # See also https://github.com/protocolbuffers/protobuf/blob/fe0a809d5ef4/src/google/protobuf/compiler/plugin.proto#L107-L109).
    supported_features=[
        google.protobuf.compiler.plugin_pb2.CodeGeneratorResponse.Feature.FEATURE_PROTO3_OPTIONAL
    ],
)
opts.run(generate)
